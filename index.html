<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>KaRIn sensor on SWOT</title>
    <meta charset="utf-8" />
    <meta name="author" content="Emily Dugmore" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# KaRIn sensor on SWOT
]
.author[
### Emily Dugmore
]
.institute[
### University College London, Centre for Advanced Spatial Analysis
]
.date[
### 2026/01/21 (updated: 2026-01-21)
]

---


# What is SWOT?
#### Surface Water and Ocean Topography satellite

- Launched on December 16, 2022 aboard a SpaceXFalcon 9 rocket
- Led by NASA (U.S.A) and SNES (France) with contributions from Canada and UK Space Agencies
- Orbits:
  - at 891km altitude
  - at 78Â° inclination
  - every 21 days
- Mission lifetime of 3.5 years

&lt;img src="images/satellite.jpg" width="60%" /&gt;

---

# What is SWOT hoping to achieve?

This satellite is focused on creating a better understanding of the world's oceans and terrestrial surface waters by making the **first global survey of Earth's surface water** elevations for ocean's, rivers, lakes and wetlands

This will allow for:
- observation of small-scale **ocean currents and eddies**
- tracking regional **sea level changes**
- monitoring **river flow rates** and **lake volume changes**

---

# Where does the **KaRIn sensor** fit in?
### Ka-Band Radar Interferometer is the primary instrument on SWOT

Traditional radar altimeters measure water height only directly beneath the satellite, limiting spatial coverage. 

KaRIn overcomes this by using two antennas seperated by 10m to observe a wide swath (about 120km) on either side of the satellite's ground track. 

The sensor operates in two modes:
- High-resolution over land (rivers, lakes)
- Lower-resolution over oceans


&lt;img src="images/sensor.png" width="60%" /&gt;

---

# Land applications

- Floods
  - Flood dynamics (rise and fall of water during flood event) can be studied
  - Mitigation and preparation
- Drought
  - Potential for development of predictive capabilities
- Reservoirs
  - Information about hanges to reservoir storage can be more widely accessible, allowing for downstream comminities to model future flow dynamics within their borders

---

# Use in study of 2024 southern Brazil flood
- SWOT satellite observations of water surface elevation and derived water slopes were used to study flood dynamics
- Researchers showed that flood was worsened by:
  1. A dramatic increase in **water slopes** (which were up to 21 times higher than in stable conditions)
  2. **Wind forcing** that raised water levels in a nearby Lagoon by up to 40cm
- These findings highlight the need to consider new flood intensifiers (water slope and wind forcing) in risk management (such as emergency warnings)
  
https://swot.jpl.nasa.gov/news/167/cutting-edge-satellite-tracks-lake-water-levels-in-ohio-river-basin/

---

# Ocean applications 

- Coastal zone management
  - Storm surge modelling
  - Sediment transport
  - Water quality issues
- Climate
  - Study the role of the ocean in regulating climate changes

---

# Implications


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
